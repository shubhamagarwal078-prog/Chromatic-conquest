import React, { useState, useEffect } from 'react';

const ChromaticConquest = () => {
  const colors = ['red', 'blue', 'green', 'yellow', 'purple'];
  const colorMap = {
    red: '#ef4444',
    blue: '#3b82f6',
    green: '#22c55e',
    yellow: '#eab308',
    purple: '#a855f7'
  };

  // Initialize board with random colors and sizes
  const initializeBoard = () => {
    const board = {};
    const gridSize = 20; // 20x20 = 400 cells for demo
    
    for (let row = 0; row < gridSize; row++) {
      for (let col = 0; col < gridSize; col++) {
        const id = `${row}-${col}`;
        board[id] = {
          id,
          row,
          col,
          color: colors[Math.floor(Math.random() * colors.length)],
          size: Math.floor(Math.random() * 3) + 1, // 1-3 size units
          owner: null,
          ownerColor: null
        };
      }
    }
    return board;
  };

  const [board, setBoard] = useState(initializeBoard);
  const [currentPlayer, setCurrentPlayer] = useState(1);
  const [selectedColors, setSelectedColors] = useState([]);
  const [gamePhase, setGamePhase] = useState('select'); // 'select' or 'expand'
  const [player1Territory, setPlayer1Territory] = useState(new Set(['0-0'])); // Top-left
  const [player2Territory, setPlayer2Territory] = useState(new Set(['19-19'])); // Bottom-right
  const [controlledColors, setControlledColors] = useState({ 1: new Set(), 2: new Set() });
  const [gameLog, setGameLog] = useState(['Game started! Player 1 begins.']);

  // Initialize starting positions
  useEffect(() => {
    setBoard(prevBoard => {
      const newBoard = { ...prevBoard };
      newBoard['0-0'].owner = 1;
      newBoard['0-0'].ownerColor = 'red';
      newBoard['19-19'].owner = 2;
      newBoard['19-19'].ownerColor = 'blue';
      return newBoard;
    });
  }, []);

  // Get adjacent cells (only sides, not diagonals)
  const getAdjacent = (row, col) => {
    const adjacent = [];
    const directions = [
      [-1, 0], // up
      [1, 0],  // down
      [0, -1], // left
      [0, 1]   // right
    ];
    
    directions.forEach(([dr, dc]) => {
      const newRow = row + dr;
      const newCol = col + dc;
      if (newRow >= 0 && newRow < 20 && newCol >= 0 && newCol < 20) {
        adjacent.push(`${newRow}-${newCol}`);
      }
    });
    
    return adjacent;
  };

  // Get available colors for current player
  const getAvailableColors = () => {
    const opponent = currentPlayer === 1 ? 2 : 1;
    return colors.filter(color => !controlledColors[opponent].has(color));
  };

  // Handle color selection
  const handleColorSelect = (color) => {
    setSelectedColors([color]); // Only allow one color selection
  };

  // Expand territory for selected color
  const expandTerritory = () => {
    if (selectedColors.length === 0) return;

    let newBoard = { ...board };
    const currentTerritory = currentPlayer === 1 ? player1Territory : player2Territory;
    let newTerritory = new Set(currentTerritory);
    let expansionHappened = false;
    const selectedColor = selectedColors[0]; // Only one color now

    // Expand into adjacent cells of the selected color
    let changed = true;
    while (changed) {
      changed = false;
      Array.from(newTerritory).forEach(cellId => {
        const cell = newBoard[cellId];
        const adjacent = getAdjacent(cell.row, cell.col);
        
        adjacent.forEach(adjId => {
          const adjCell = newBoard[adjId];
          if (adjCell && adjCell.color === selectedColor && !adjCell.owner) {
            newBoard[adjId] = {
              ...adjCell,
              owner: currentPlayer,
              ownerColor: selectedColor
            };
            newTerritory.add(adjId);
            changed = true;
            expansionHappened = true;
          }
        });
      });
    }

    // Update territory
    if (currentPlayer === 1) {
      setPlayer1Territory(newTerritory);
    } else {
      setPlayer2Territory(newTerritory);
    }

    // Update controlled colors
    const newControlledColors = { ...controlledColors };
    colors.forEach(color => {
      const totalColorCells = Object.values(newBoard).filter(cell => cell.color === color);
      const player1ColorCells = totalColorCells.filter(cell => cell.owner === 1);
      const player2ColorCells = totalColorCells.filter(cell => cell.owner === 2);
      
      const totalColorArea = totalColorCells.reduce((sum, cell) => sum + cell.size, 0);
      const player1ColorArea = player1ColorCells.reduce((sum, cell) => sum + cell.size, 0);
      const player2ColorArea = player2ColorCells.reduce((sum, cell) => sum + cell.size, 0);
      
      // Remove from both players first
      newControlledColors[1].delete(color);
      newControlledColors[2].delete(color);
      
      // Add to majority controller
      if (player1ColorArea > totalColorArea / 2) {
        newControlledColors[1].add(color);
      } else if (player2ColorArea > totalColorArea / 2) {
        newControlledColors[2].add(color);
      }
    });

    setControlledColors(newControlledColors);
    setBoard(newBoard);
    
    // Add to game log
    if (expansionHappened) {
      const newScores = calculateScores();
      setGameLog(prev => [...prev, `Player ${currentPlayer} expanded using color: ${selectedColor} - Now controls ${newScores[`player${currentPlayer}Percentage`]}% of board`]);
    } else {
      setGameLog(prev => [...prev, `Player ${currentPlayer} selected ${selectedColor} but no expansion possible`]);
    }

    // End turn
    setSelectedColors([]);
    setCurrentPlayer(currentPlayer === 1 ? 2 : 1);
    setGamePhase('select');
  };

  // Calculate scores and percentages
  const calculateScores = () => {
    const totalBoardArea = Object.values(board).reduce((sum, cell) => sum + cell.size, 0);
    
    const player1Score = Array.from(player1Territory).reduce((sum, cellId) => {
      return sum + board[cellId]?.size || 0;
    }, 0);
    
    const player2Score = Array.from(player2Territory).reduce((sum, cellId) => {
      return sum + board[cellId]?.size || 0;
    }, 0);
    
    const player1Percentage = totalBoardArea > 0 ? ((player1Score / totalBoardArea) * 100).toFixed(1) : 0;
    const player2Percentage = totalBoardArea > 0 ? ((player2Score / totalBoardArea) * 100).toFixed(1) : 0;
    const unoccupiedPercentage = totalBoardArea > 0 ? (((totalBoardArea - player1Score - player2Score) / totalBoardArea) * 100).toFixed(1) : 0;
    
    return { 
      player1Score, 
      player2Score, 
      player1Percentage, 
      player2Percentage,
      unoccupiedPercentage,
      totalBoardArea
    };
  };

  const { player1Score, player2Score, player1Percentage, player2Percentage, unoccupiedPercentage, totalBoardArea } = calculateScores();
  const availableColors = getAvailableColors();

  return (
    <div className="p-6 bg-gray-100 min-h-screen">
      <h1 className="text-3xl font-bold text-center mb-6">Chromatic Conquest</h1>
      
      {/* Game Status */}
      <div className="bg-white rounded-lg p-4 mb-4">
        <div className="flex justify-between items-center mb-4">
          <div className="text-xl font-semibold">
            Current Player: <span className={currentPlayer === 1 ? 'text-red-600' : 'text-blue-600'}>
              Player {currentPlayer}
            </span>
          </div>
          <div className="text-lg">
            Score - Player 1: <span className="text-red-600 font-bold">{player1Score}</span> ({player1Percentage}%) | 
            Player 2: <span className="text-blue-600 font-bold">{player2Score}</span> ({player2Percentage}%)
          </div>
          <div className="text-sm text-gray-600">
            Total Board Area: {totalBoardArea} | Unoccupied: {unoccupiedPercentage}%
          </div>
        </div>
        
        {/* Color Selection */}
        <div className="mb-4">
          <h3 className="text-lg font-semibold mb-2">Select one color:</h3>
          <div className="flex gap-2 mb-2">
            {availableColors.map(color => (
              <button
                key={color}
                onClick={() => handleColorSelect(color)}
                className={`px-4 py-2 rounded border-2 ${
                  selectedColors.includes(color) 
                    ? 'border-gray-800 opacity-100' 
                    : 'border-gray-300 opacity-60'
                }`}
                style={{ backgroundColor: colorMap[color], color: 'white' }}
              >
                {color.charAt(0).toUpperCase() + color.slice(1)}
              </button>
            ))}
          </div>
          <div className="text-sm text-gray-600 mb-2">
            Selected: {selectedColors.join(', ') || 'None'}
          </div>
          <button
            onClick={expandTerritory}
            disabled={selectedColors.length === 0}
            className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:bg-gray-400"
          >
            Expand Territory
          </button>
        </div>

        {/* Controlled Colors Display */}
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <strong>Player 1 Controls:</strong> {Array.from(controlledColors[1]).join(', ') || 'None'}
          </div>
          <div>
            <strong>Player 2 Controls:</strong> {Array.from(controlledColors[2]).join(', ') || 'None'}
          </div>
        </div>
      </div>

      {/* Game Board */}
      <div className="bg-white rounded-lg p-4 mb-4">
        <div className="grid grid-cols-20 gap-0 border border-gray-300" style={{ gridTemplateColumns: 'repeat(20, 1fr)' }}>
          {Array.from({ length: 400 }, (_, i) => {
            const row = Math.floor(i / 20);
            const col = i % 20;
            const cellId = `${row}-${col}`;
            const cell = board[cellId];
            
            if (!cell) return null;
            
            let backgroundColor = colorMap[cell.color];
            let borderColor = 'border-gray-200';
            let textColor = 'text-white';
            
            if (cell.owner === 1) {
              borderColor = 'border-red-800 border-2';
              backgroundColor = colorMap[cell.ownerColor];
            } else if (cell.owner === 2) {
              borderColor = 'border-blue-800 border-2';
              backgroundColor = colorMap[cell.ownerColor];
            }
            
            return (
              <div
                key={cellId}
                className={`aspect-square flex items-center justify-center text-xs font-bold ${borderColor} ${textColor}`}
                style={{ backgroundColor }}
                title={`${cellId}: ${cell.color}, size: ${cell.size}, owner: ${cell.owner || 'none'}`}
              >
                {cell.size}
              </div>
            );
          })}
        </div>
        <div className="text-xs text-gray-600 mt-2">
          Red border = Player 1 territory | Blue border = Player 2 territory | Numbers show cell size<br/>
          Adjacent = only up/down/left/right (no diagonals)
        </div>
      </div>

      {/* Game Log */}
      <div className="bg-white rounded-lg p-4">
        <h3 className="text-lg font-semibold mb-2">Game Log</h3>
        <div className="max-h-32 overflow-y-auto">
          {gameLog.map((entry, index) => (
            <div key={index} className="text-sm text-gray-700 mb-1">
              {entry}
            </div>
          ))}
        </div>
      </div>

      {/* Instructions */}
      <div className="bg-white rounded-lg p-4 mt-4">
        <h3 className="text-lg font-semibold mb-2">How to Play</h3>
        <ul className="text-sm text-gray-700 space-y-1">
          <li>• Select one color per turn (cannot choose colors controlled by opponent)</li>
          <li>• Click "Expand Territory" to capture adjacent cells of that color</li>
          <li>• All newly captured areas become the color you selected</li>
          <li>• Control majority of a color (>50% of its total area) to deny it to opponent</li>
          <li>• Win by controlling the most total area</li>
        </ul>
      </div>
    </div>
  );
};

export default ChromaticConquest;
